==================================================
FILE: ./src/ast/NodeDecl.java
==================================================
package ast;

public class NodeDecl extends NodeDecSt {
	public LangType type;
	public NodeId id;
	public NodeExpr init;
	public NodeDecl(LangType type, NodeId id, NodeExpr init) {
		super();
		this.type = type;
		this.id = id;
		this.init = init;
	}
	public LangType getType() {
		return type;
	}
	public NodeId getId() {
		return id;
	}
	public NodeExpr getInit() {
		return init;
	}
	
}
-e 


==================================================
FILE: ./src/ast/NodeStm.java
==================================================
package ast;

public abstract class NodeStm extends NodeDecSt{

}
-e 


==================================================
FILE: ./src/ast/NodeExpr.java
==================================================
package ast;

public abstract class NodeExpr {

}
-e 


==================================================
FILE: ./src/ast/LangOper.java
==================================================
package ast;

public enum LangOper {

}
-e 


==================================================
FILE: ./src/ast/LangType.java
==================================================
package ast;

public enum LangType {

}
-e 


==================================================
FILE: ./src/ast/NodeAST.java
==================================================
package ast;

public abstract class NodeAST {

}
-e 


==================================================
FILE: ./src/ast/NodePrint.java
==================================================
package ast;

public class NodePrint extends NodeStm {
	public NodeId Id;
	public NodePrint(NodeId id) {
		super();
		this.Id = id;
	}
	public NodeId getId() {
		return Id;
	}
	@Override
	public String toString() {
		return "NodePrint [Id=" + Id + "]";
	}
}
-e 


==================================================
FILE: ./src/ast/NodeProgram.java
==================================================
package ast;
import  java.util.ArrayList;
public class NodeProgram extends NodeAST {
	private ArrayList<NodeDecSt> decSts;
	public NodeProgram(ArrayList<NodeDecSt> decSts) {
		this.decSts=decSts;
	}
	public ArrayList<NodeDecSt> getDecSts() {
		return decSts;
	}
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder("NodeProgram(");
		for(int i=0;i<decSts.size();i++) {
			sb.append(decSts.get(i).toString());
			if(i< decSts.size() -1) {
				sb.append(",");
			}
		}
		sb.append(")");
		return sb.toString();
	}
	
}
-e 


==================================================
FILE: ./src/ast/NodeDecSt.java
==================================================
package ast;

public abstract class NodeDecSt {

}
-e 


==================================================
FILE: ./src/ast/NodeId.java
==================================================
package ast;

public class NodeId {
	

	public String name;

	public NodeId(String name) {
		super();
		this.name = name;
	}

	@Override
	public String toString() {
		return "NodeId [name=" + name + "]";
	}

	public String getName() {
		return name;
	}
	
}
-e 


==================================================
FILE: ./src/test/TestToken.java
==================================================
package test;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

import token.Token;
import token.TokenType;

class TestToken {

	@Test
	void test() {

	}

}
-e 


==================================================
FILE: ./src/test/TestScanner.java
==================================================
package test;

import scanner.*;
import token.*;
import static org.junit.jupiter.api.Assertions.*;

import java.io.FileNotFoundException;

import org.junit.jupiter.api.Test;

class TestScanner {

	@Test
	void testKeyWords() throws Exception {
		Scanner sc = new Scanner("src/test/data/testScanner/testIdKeyWords.txt");
		assertEquals(TokenType.TYINT, sc.nextToken().getType());
		assertEquals(TokenType.ID, sc.nextToken().getType());
		assertEquals(TokenType.TYFLOAT, sc.nextToken().getType());
		assertEquals(TokenType.PRINT, sc.nextToken().getType());
		assertEquals(TokenType.ID, sc.nextToken().getType());
		assertEquals(TokenType.ID, sc.nextToken().getType());
		assertEquals(TokenType.TYINT, sc.nextToken().getType());
		assertEquals(TokenType.ID, sc.nextToken().getType());

	}

	@Test
	void peekToken() throws FileNotFoundException, LexicalException {
		Scanner s = new Scanner("src/test/data/testScanner/testGenerale.txt");
		assertEquals(s.peekToken().getType(), TokenType.TYINT);
		assertEquals(s.nextToken().getType(), TokenType.TYINT);
		assertEquals(s.peekToken().getType(), TokenType.ID);
		assertEquals(s.peekToken().getType(), TokenType.ID);
		Token t = s.nextToken();
		assertEquals(t.getType(), TokenType.ID);
		assertEquals(t.getRiga(), 1);
		assertEquals(t.getValore(), "temp");
	}

	@Test
	void testInt() throws FileNotFoundException, LexicalException {
		Scanner s = new Scanner("src/test/data/testScanner/testInt.txt");
		assertEquals(TokenType.INT, s.nextToken().getType());
		assertEquals(TokenType.INT, s.nextToken().getType());
		assertEquals(TokenType.INT, s.nextToken().getType());
		assertEquals(TokenType.INT, s.nextToken().getType());
	}

	void testFloat() throws FileNotFoundException, LexicalException {
		Scanner s = new Scanner("src/test/data/testScanner/testFloat.txt");
		assertEquals(TokenType.FLOAT, s.nextToken().getType());
		assertEquals(TokenType.FLOAT, s.nextToken().getType());
		assertEquals(TokenType.FLOAT, s.nextToken().getType());
		assertEquals(TokenType.FLOAT, s.nextToken().getType());
	}

}
-e 


==================================================
FILE: ./src/parser/SyntacticException.java
==================================================
package parser;

public class SyntacticException extends Exception {
	public SyntacticException(String message) {
		super(message);
	}

	// Costruttore per il chaining delle eccezioni (es. LexicalException)
	public SyntacticException(String message, Throwable cause) {
		super(message, cause);
	}
}
-e 


==================================================
FILE: ./src/parser/Parser.java
==================================================
package parser;

import scanner.Scanner;
import scanner.LexicalException;
import token.TokenType;
import token.Token;

//Il parser verifica se la sequenza di token soddisfa la grammatica del linguaggio
public class Parser {
	private scanner.Scanner sc;

	public Parser(Scanner sc) {
		this.sc = sc;
	}
	/*
	 * public void parse() throws SyntacticException { return this.parsePrg(); }
	 */

	private Token peekWithChaining() throws SyntacticException {
		try {
			return sc.peekToken();
		} catch (LexicalException e) {
			// Chaining formale: passo l'eccezione originale come causa [5, 6]
			throw new SyntacticException("Errore lessicale durante l'ispezione del token", e);
		}
	}

	private void parsePrg() throws SyntacticException {
		Token tk = peekWithChaining();
		switch (tk.getType()) {
		case TYFLOAT, TYINT, ID, PRINT, EOF -> {
			parseDSs();
			match(TokenType.EOF);
		}
		default -> {
			throw new SyntacticException("Token" + tk.getType() + "non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}

	private void parseDSs() throws SyntacticException {
		Token tk = peekWithChaining();
		switch (tk.getType()) {
		case TYFLOAT, TYINT -> {
			parseDcl();
			parseDSs();
		}
		case ID, PRINT -> {
			parseStm();
			parseDSs();
		}
		case EOF -> {
			return;
		}
		default -> {
			throw new SyntacticException("Token" + tk.getType() + "non valido come inizio alla riga: " + tk.getRiga());
		}
		}

	}

	private void parseDcl() throws SyntacticException {
		Token tk = peekWithChaining();
		switch (tk.getType()) {
		case TYFLOAT, TYINT -> {
			parseTy();
			match(TokenType.ID);
			parseDclP();
		}
		default -> {
			throw new SyntacticException("Token" + tk.getType() + "non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}

	private void parseTy() throws SyntacticException {
		Token tk = peekWithChaining();
		switch (tk.getType()) {
		case TYFLOAT -> match(TokenType.TYFLOAT);
		case TYINT -> match(TokenType.TYINT);
		default ->
			throw new SyntacticException("Token" + tk.getType() + "non valido come inizio alla riga: " + tk.getRiga());
		}
	}

	private void parseDclP() throws SyntacticException {
		Token tk = peekWithChaining();
		switch (tk.getType()) {
		case SEMI -> match(TokenType.SEMI);
		case ASSIGN -> {
			match(TokenType.ASSIGN);
			parseExp();
			match(TokenType.SEMI);
		}
		default -> {
			throw new SyntacticException(
					"Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}

	}

	private void parseStm() throws SyntacticException {
		Token tk = peekWithChaining();
		switch (tk.getType()) {
		case ID -> {
			match(TokenType.ID);
			parseOp();
			parseExp();
			match(TokenType.SEMI);
		}
		case PRINT -> {
			match(TokenType.PRINT);
			match(TokenType.ID);
			match(TokenType.SEMI);
		}
		default -> {
			throw new SyntacticException(
					"Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}
	private void parseExp() throws SyntacticException{
		Token tk= peekWithChaining();
		switch(tk.getType()) {
		case ID,FLOAT,INT->{
			parseTr();
			parseExpP();
		}
		default ->{
			throw new SyntacticException(
					"Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}
	private void parseExpP() throws SyntacticException{
		Token tk= peekWithChaining();
		switch(tk.getType()) {
		case PLUS ->{
			match(TokenType.PLUS);
			parseTr();
			parseExpP();
		}
		case MINUS ->{
			match(TokenType.MINUS);
			parseTr();
			parseExpP();
		}
		case SEMI ->{
			return;
		}
		default->{
			throw new SyntacticException("Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}
	private void parseTr() throws SyntacticException{
		Token tk= peekWithChaining();
		switch(tk.getType()) {
		case ID, FLOAT, INT ->{
			parseVal();
			parseTrP();
		}
		default->{
			throw new SyntacticException("Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}
	private void parseTrP() throws SyntacticException{
		Token tk= peekWithChaining();
		switch(tk.getType()) {
		case TIMES->{
			match(TokenType.TIMES);
			parseVal();
			parseTrP();
		}
		case DIVIDE->{
			match(TokenType.DIVIDE);
			parseVal();
			parseTrP();
		}
		case MINUS,PLUS,SEMI ->{
			return;
		}
		default->{
			throw new SyntacticException("Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}
		
	}
	private void parseVal() throws SyntacticException{
		Token tk=peekWithChaining();
		switch(tk.getType()) {
		case INT -> {
			match(TokenType.INT);
		}
		case FLOAT -> { 
			match(TokenType.FLOAT);
		}
		case ID -> {
			match(TokenType.ID);
		}
		default->{
			throw new SyntacticException("Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}	
	}
	private void parseOp() throws SyntacticException{
		Token tk=peekWithChaining();
		switch(tk.getType()) {
		case ASSIGN ->{
			match(TokenType.ASSIGN);
		}
		case OP_ASSIGN -> {
			match(TokenType.OP_ASSIGN);
		}
		default->{
			throw new SyntacticException("Token " + tk.getType() + " non valido come inizio alla riga: " + tk.getRiga());
		}
		}
	}
	// metodo parse

	/*
	 * Questo metodo ha il compito di: • Controllare se il tipo del prossimo token
	 * (ottenuto tramite peekToken()) corrisponde a quello atteso. • Consumare il
	 * token chiamando nextToken() se il tipo è corretto. • Sollevare una
	 * SyntacticException se il tipo non corrisponde, indicando la riga e il motivo
	 * dell'errore.
	 */
	private Token match(TokenType Type) throws SyntacticException {
		Token t = peekWithChaining();
		if (Type.equals(t.getType())) {
			try {
				return sc.nextToken(); // Consuma e ritorna il token [7, 8]
			} catch (LexicalException e) {
				throw new SyntacticException("Errore lessicale durante il consumo del token", e);
			}
		} else {
			throw new SyntacticException(
					"Errore Sintattico: atteso " + Type + " ma trovato " + t.getType() + " alla riga " + t.getRiga());

		}
	}

}
-e 


==================================================
FILE: ./src/scanner/Scanner.java
==================================================
package scanner;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PushbackReader;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import token.*;

public class Scanner {
	final char EOF = (char) -1;
	private int riga;
	private PushbackReader buffer;
	/*
	 * Liste: Per rappresentare insiemi di caratteri è preferibile usare strutture
	 * come Set<Character>
	 */
	private Set<Character> skipChars;// skpChars: insieme caratteri di skip (include EOF) e inizializzazione
	private Set<Character> letters; // letters: insieme lettere
	private Set<Character> digits; // digits: cifre

	private Map<Character, TokenType> operTkType;// operTkType: mapping fra caratteri '+', '-', '*', '/' e il TokenType
													// corrispondente
	private Map<Character, TokenType> delimTkType;// delimTkType: mapping fra caratteri '=', ';' e il e il TokenType
													// corrispondente
	private Map<String, TokenType> keyWordsTkType; // keyWordsTkType: mapping fra le stringhe "print", "float", "int" e
													// il TokenType corrispondente

	// campo per nextToken
	private Token nextTk;

	public Scanner(String fileName) throws FileNotFoundException {

		this.buffer = new PushbackReader(new FileReader(fileName));
		riga = 1;
		// inizializzare campi che non hanno inizializzazione
		initSetsAndMaps();
	}

	public Scanner(int riga, PushbackReader buffer, Set<Character> skipChars, Set<Character> letters,
			Set<Character> digits, Map<Character, TokenType> operTkType, Map<Character, TokenType> delimTkType,
			Map<String, TokenType> keyWordsTkType) {
		super();
		this.riga = riga;
		this.buffer = buffer;
		this.skipChars = skipChars;
		this.letters = letters;
		this.digits = digits;
		this.operTkType = operTkType;
		this.delimTkType = delimTkType;
		this.keyWordsTkType = keyWordsTkType;
	}

	// ------------------------------------------------------------
	// Inizializzazione insiemi e mappe
	// ------------------------------------------------------------
	private void initSetsAndMaps() {
		// caratteri di skip
		skipChars = new HashSet<>();
		skipChars.add(' ');
		skipChars.add('\t');
		skipChars.add('\r');
		skipChars.add('\n');
		// NB: non metto EOF qui, lo gestisco esplicitamente

		// lettere
		letters = new HashSet<>();
		for (char c = 'a'; c <= 'z'; c++)
			letters.add(c);
		for (char c = 'A'; c <= 'Z'; c++)
			letters.add(c);

		// cifre
		digits = new HashSet<>();
		for (char c = '0'; c <= '9'; c++)
			digits.add(c);

		// operatori aritmetici
		operTkType = new HashMap<>();
		operTkType.put('+', TokenType.PLUS);
		operTkType.put('-', TokenType.MINUS);
		operTkType.put('*', TokenType.TIMES);
		operTkType.put('/', TokenType.DIVIDE);

		// delimitatori (=, ;)
		delimTkType = new HashMap<>();
		delimTkType.put('=', TokenType.ASSIGN);
		delimTkType.put(';', TokenType.SEMI);

		// parole chiave: int, float, print
		keyWordsTkType = new HashMap<>();
		keyWordsTkType.put("int", TokenType.TYINT);
		keyWordsTkType.put("float", TokenType.TYFLOAT);
		keyWordsTkType.put("print", TokenType.PRINT);
	}

	// nextToken ritorna il prossimo token nel file di input e legge
	// i caratteri del token ritornato (avanzando fino al carattere
	// successivo all'ultimo carattere del token)
	public Token nextToken() throws LexicalException {
		char nextChar;
		if (nextTk != null) {
			Token t = nextTk;
			nextTk = null;
			return t;
		}
		// nextChar contiene il prossimo carattere dell'input (non consumato).
		try {
			nextChar = peekChar(); // Catturate l'eccezione IOException e
			// ritornate una LexicalException che la contiene
		} catch (IOException e) {
			throw new LexicalException("Errore alla riga: " + riga + e);
		}

		// Avanza nel buffer leggendo i carattere in skipChars
		// incrementando riga se leggi '\n'.
		while (skipChars.contains(nextChar)) {
			try {
				char c = readChar();
				if (c == '\n')
					riga++;
				nextChar = peekChar();
			} catch (IOException e) {
				throw new LexicalException("Errore di I/O durante lo skip dei caratteri alla riga: " + riga + e);
			}
		}
		// Se raggiungi la fine del file ritorna il Token EOF
		if (nextChar == EOF) {
			return new Token(TokenType.EOF, riga, "EOF");
		}
		// Se nextChar e' in letters
		// return scanId()
		// che deve generare o un Token ID o parola chiave
		if (letters.contains(nextChar)) {
			return ScanId();
		}
		// Se nextChar e' o in operators oppure delimitatore
		// ritorna il Token associato con l'operatore o il delimitatore
		// Attenzione agli operatori di assegnamento!
		if (operTkType.containsKey(nextChar) || delimTkType.containsKey(nextChar)) {
			return scanOperator();
		}
		// Se nextChar e' ; o =
		// ritorna il Token associato
		if (digits.contains(nextChar)) {
			return scanNumber();
		}

		throw new LexicalException("Carattere illegale '" + nextChar + "' alla riga " + riga);
	}

	public Token peekToken() throws LexicalException {
		if (nextTk == null) {
			nextTk = nextToken();
		}
		return nextTk;
	}

	// Regola: ID-->lettera(lettera | cifra)*
	// dallo stato 0 se leggo una lettera entro nel 3, continuo a leggere lettere o
	// cifre finchè non avanzo
	private Token ScanId() throws LexicalException {
		StringBuilder sb = new StringBuilder();
		try {
			char c = readChar(); // 1- Entrata nello stato 3: stato 0--> leggo una lettera --> transizione a
									// stato 3
			sb.append(c);

			char next = peekChar(); // 2- Serve a decidere se l' automa può avanzare senza consumare caratteri
									// inutilmente
			while (letters.contains(next) || digits.contains(next)) { // 3- accumulo il lexeme andando avanti il più
																		// possibile
				c = readChar();
				sb.append(c);
				next = peekChar();
			} // 4- se non è ne' lettera nè cifra esco dal loop
		} catch (IOException e) {
			throw new LexicalException("Errore di I/O leggendo un identificatore alla riga " + riga + e);
		}
		String lexeme = sb.toString(); // lexeme= sequenza di caratteri letti da input
		// parola chiave?
		TokenType kwType = keyWordsTkType.get(lexeme);
		if (kwType != null) {
			return new Token(kwType, riga, lexeme);
		}

		// altrimenti ID
		return new Token(TokenType.ID, riga, lexeme);
	}// non serve controllo di errore perchè scanId viene chiamato solo se il primo
		// carattere è lettera

	private Token scanOperator() throws LexicalException// devo scannerizzare l' operatore, prima di farlo capisco se
														// serve con peekChar()
	{
		char first;
		// leggo e consumo il primo carattere
		try {
			first = readChar();
		} catch (IOException e) {
			throw new LexicalException("Errore di I/O alla riga " + riga + e);
		}
		// caso operatori aritmetici composti
		if (operTkType.containsKey(first)) {
			try {
				char next = peekChar();

				if (next == '=') {
					readChar();
					String lexeme = "" + first + "=";
					return new Token(TokenType.OP_ASSIGN, riga, lexeme);
				}
			} catch (IOException e) {
				throw new LexicalException("Errore alla riga " + riga + e);
			}
			return new Token(operTkType.get(first), riga, Character.toString(first));
		}
		// Caso delimitatori: = ;
		if (delimTkType.containsKey(first)) {
			return new Token(delimTkType.get(first), riga, Character.toString(first));
		}

		// caso impossibile (per sicurezza)
		throw new LexicalException("Carattere '" + first + "' non valido alla riga " + riga);

	}

	/*
	 * Se nextChar e' in numbers return scanNumber() // che legge sia un intero che
	 * un float e ritorna il Token INUM o FNUM // i caratteri che leggete devono
	 * essere accumulati in una stringa // che verra' assegnata al campo valore del
	 * Token
	 * 
	 * // Altrimenti il carattere NON E' UN CARATTERE LEGALE sollevate una //
	 * eccezione lessicale dicendo la riga e il carattere che la hanno // provocata.
	 */
	private Token scanNumber() throws LexicalException {
		StringBuilder sb = new StringBuilder();
		char c;
		int contDec = 0;
		try {
			c = readChar();
			sb.append(c);
			char next = peekChar();
			while (digits.contains(next)) {
				c = readChar();
				sb.append(c);
				next = peekChar();
			}
			if (next != '.') {
				String lexeme = sb.toString();
				return new Token(TokenType.INT, riga, lexeme);
			}

			// Float: consuma il punto
			c = readChar();
			sb.append(c);

			next = peekChar();
			if (!digits.contains(next)) {
				throw new LexicalException("Numero non valido alla riga " + riga + ": manca la parte decimale");
			}
			while (digits.contains(next)) {
				c = readChar();
				sb.append(c);
				contDec++;
				if (contDec > 5) {
					throw new LexicalException("Numero reale con piu' di 5 cifre decimali alla riga " + riga);
				}
				next = peekChar();
			}
			return new Token(TokenType.FLOAT, riga, sb.toString());
		} catch (IOException e) {
			throw new LexicalException("Errore di I/O leggendo un numero alla riga " + riga + e);
		}

	}

	public Scanner(int riga, PushbackReader buffer) {
		super();
		this.riga = riga;
		this.buffer = buffer;
	}

	private char readChar() throws IOException {
		return ((char) this.buffer.read());
	}

	private char peekChar() throws IOException {
		char c = (char) buffer.read();
		buffer.unread(c);
		return c;
	}
}
-e 


==================================================
FILE: ./src/scanner/LexicalException.java
==================================================
package scanner;

public class LexicalException extends Exception {

	public LexicalException(String message) {
		super(message);
	}

	// Costruttori

}
-e 


==================================================
FILE: ./src/token/TokenType.java
==================================================
package token;

public enum TokenType {
	PLUS, MINUS, DIVIDE, TIMES, INT, FLOAT, ID, TYINT, TYFLOAT, PRINT, OP_ASSIGN, ASSIGN, SEMI, EOF;
}
-e 


==================================================
FILE: ./src/token/Token.java
==================================================
package token;

public class Token {
	// int riga
	// token type
	// valore
	private int riga;
	private TokenType type;
	private String Valore;// opzionale, definisco un costruttore apposta

	// costruttore
	public Token(TokenType tipo, int riga, String Valore) {
		this.type = tipo;
		this.riga = riga;
		this.Valore = Valore;
	}

	public Token(TokenType tipo, int riga) {
		super();
		this.type = tipo;
		this.riga = riga;
	}

	public String getValore() {
		return Valore;
	}

	public int getRiga() {
		return riga;
	}

	public TokenType getType() {
		return type;
	}

	@Override
	public String toString() {
		return "Token [riga=" + riga + ", type=" + type + ", Valore=" + Valore + ", toString()=" + super.toString()
				+ "]";
	}

}
-e 


